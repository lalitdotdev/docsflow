import {
  ApiBadRequestResponse,
  ApiBody,
  ApiOkResponse,
  ApiOperation,
  ApiSecurity,
  ApiTags,
  ApiUnauthorizedResponse,
  ApiUnprocessableEntityResponse,
} from '@nestjs/swagger';
import {
  Body,
  Controller,
  HttpCode,
  InternalServerErrorException,
  Post,
  UnprocessableEntityException,
} from '@nestjs/common';

import { JsonService } from './json.service';
import {
  JsonExtractExampleRequestDto,
  JsonExtractSchemaRequestDto,
} from './dtos/jsonExtractRequest.dto';
import { JsonExtractResultDto } from './dtos/jsonExtractResult.dto';
import { InvalidJsonOutputError } from './exceptions/exceptions';

@ApiUnauthorizedResponse({
  description: "The API key in request's header is missing or invalid.",
})
@ApiBadRequestResponse({
  description: 'The request body is invalid or missing.',
})
@ApiUnprocessableEntityResponse({
  description:
    'The output is not valid json or cannot be generated by the langage model.',
})
@ApiSecurity('apiKey')
@ApiTags('structured-data')
@Controller({
  path: 'structured-data/json',
  version: '1',
})
export class JsonController {
  constructor(private readonly jsonService: JsonService) {
    // this.logger.setContext(JsonController.name);
  }

  @ApiOperation({
    summary: 'Return structured data from text as json using a json schema',
    description: `This endpoint returns structured data from input text as json.
    It accepts a json schema as model for data extraction. The Refine technique can be used for longer texts.\n

    Available models: gpt-3.5-turbo, gpt-3.5-turbo-16k, gpt-4
    `,
  })
  @ApiOkResponse({
    type: JsonExtractResultDto,
    description:
      'The text was successfully structured as json. The output is a valid json object.',
  })
  @ApiBody({
    type: JsonExtractSchemaRequestDto,
    description:
      'Request body containing text to process as json and extraction parameters',
  })
  @HttpCode(200)
  @Post('schema')
  async extractSchema(@Body() request: JsonExtractSchemaRequestDto) {
    const { text, model, jsonSchema, refine } = request;

    if (refine) {
      // this.logger.debug('refine is true');
      const { json, refineRecap } =
        await this.jsonService.extractWithSchemaAndRefine(
          model,
          text,
          jsonSchema,
          typeof refine === 'object' ? refine : undefined,
          //
        );
      const response: JsonExtractResultDto = {
        model: model.name,
        refine: refineRecap,
        output: JSON.stringify(json),
        //   debug: debug ? debugReport : undefined,
      };
      // this.logger.debug('Request processed successfully');
      return response;
    } else {
      const { json } = await this.jsonService.extractWithSchema(
        model,
        text,
        jsonSchema,
        //   debug,
      );
      const response: JsonExtractResultDto = {
        model: model.name,
        refine: false,
        output: JSON.stringify(json),
        // debug: debug ? debugReport : undefined,
      };

      //   this.logger.debug(
      //     'Request for json extraction with schema processed successfully',
      //   );
      return response;
    }
  }
  catch(error: any) {
    if (error instanceof InvalidJsonOutputError) {
      throw new UnprocessableEntityException(error.message);
    }
    throw new InternalServerErrorException();
  }

  @ApiOperation({
    summary:
      'Return structured data from text as json using an example of input and output',
    description: `This endpoint returns structured data from input text as json.
    It accepts a fully featured example with a given input text and a desired output json which will be used for data extraction.
    If chunking is needed, the zero-shot variant with a schema is better suited for the task.\n

    Available models: gpt-3.5-turbo, gpt-3.5-turbo-16k, gpt-4
    `,
  })
  @ApiOkResponse({
    type: JsonExtractResultDto,
    description:
      'The text was successfully structured as json. The output is a valid json object.',
  })
  @ApiBody({
    type: JsonExtractExampleRequestDto,
    description:
      'Request body containing text to process as json and extraction parameters',
  })
  @HttpCode(200)
  @Post('example')
  async extractExample(@Body() request: JsonExtractExampleRequestDto) {
    const { text, model, debug, exampleInput, exampleOutput } = request;
    try {
      const { json, debugReport } = await this.jsonService.extractWithExample(
        model,
        text,
        {
          input: exampleInput,
          output: exampleOutput,
        },
        debug,
      );

      const response: JsonExtractResultDto = {
        model: model.name,
        refine: false,
        output: JSON.stringify(json),
        debug: debug ? debugReport : undefined,
      };

      //   this.logger.debug(
      //     'Request for json extraction with example processed successfully',
      //   );
      return response;
    } catch (e) {
      if (e instanceof InvalidJsonOutputError) {
        throw new UnprocessableEntityException(e.message);
      }
      throw new InternalServerErrorException();
    }
  }
}
